//The Error "task main not found" is normal! DO NOT ADD TASK MAIN HERE!

#define LCD_WIDTH DISPLAY_WIDTH //100
#define LCD_HEIGHT DISPLAY_HEIGHT //64
#define CHAR_HEIGHT 8
#define CHAR_WIDTH 5
#define CHARS_PER_ROW 16
#define CHARS_PER_COLUMN 8
#define LU 0
#define RU 0
#define LD 0
#define RD 0

int ERR = 0;

/*******************************************************
 *                      RECTANGLE                      *
 *******************************************************/
struct Rect {//(Default) From the Left-Top Corner
 int X;
 int Y;
 int X2;
 int Y2;
 int width;
 int height;
};
  //Correcture-Functions
void Rect_X(Rect &in)      { in.X = in.X2 - in.width;  };
void Rect_Y(Rect &in)      { in.Y = in.Y2 - in.height; };
void Rect_X2(Rect &in)     { in.X2 = in.X + in.width;  };
void Rect_Y2(Rect &in)     { in.Y2 = in.Y + in.height; };
void Rect_width(Rect &in)  { in.width = in.X2 - in.X;  };
void Rect_height(Rect &in) { in.height = in.Y2 - in.Y; };
//=======================================================================================================
void Rect_RInit(Rect &in, int X, int Y, int width, int height)
{//Relative Init
 in.X = X;
 in.Y = Y;
 in.width = width;
 in.height = height;
 Rect_X2(in);
 Rect_Y2(in);
};
void Rect_AInit(Rect &in, int X, int Y, int X2, int Y2)
{//Absolute Init
 in.X = X;
 in.Y = Y;
 in.X2 = X2;
 in.Y2 = Y2;
 Rect_width(in);
 Rect_height(in);
};
//=======================================================================================================
bool Rect_RMove(Rect &in, int XMOV, int YMOV)
{
 //Relative Move
 int Nextx = in.X + XMOV;
 int Nexty = in.Y + YMOV;

 in.X = Nextx;
 Rect_X2(in);
 
 in.Y = Nexty;
 Rect_Y2(in);
 return true;
};
//=======================================================================================================
bool Rect_AMove(Rect &in, int X, int Y)
{
 //Absolute Move
 in.X = X;
 Rect_X2(in);
 in.Y = Y;
 Rect_Y2(in);
 return true;
};
//=======================================================================================================
bool Rect_RResize(Rect &in, int Nwidth, int Nheight)
{
 //Relative Resize
 in.width = Nwidth;
 in.height = Nheight;
 Rect_X2(in);
 Rect_Y2(in);
 return true;
};
//=======================================================================================================
bool Rect_AResize(Rect &in, int X2, int Y2)
{
 //Absolute Resize
 in.X2 = X2;
 in.Y2 = Y2;
 Rect_width(in);
 Rect_height(in);
 return true;
};
//=======================================================================================================
void Rect_Reset(Rect &in)
{
 in.X = 0;
 in.Y = 0;
 in.X2 = 0;
 in.Y2 = 0;
 in.width = 0;
 in.height = 0;
};
//=======================================================================================================
void Rect_Print(Rect in, unsigned long options = DRAW_OPT_NORMAL)
{
 RectOut(in.X, in.Y, in.width, in.height, options);
};
//=======================================================================================================
bool Rect_Overlap(Rect rA, Rect rB) {
 if (rA.X <= rB.X2 && rA.X2 >= rB.X && rA.Y >= rB.Y2 && rA.Y2 <= rB.Y) {
  return true;
 } else {
  return false;
 };
};
/*******************************************************
 *                    END RECTANGLE                    *
 *******************************************************
 *                        MISC                         *
 *******************************************************/

long map(long num, long in_min, long in_max, long out_min, long out_max); //Prototype for rnd()

long rnd(long min, long max)
{
 return map(rand(), 0, RAND_MAX, min, max);
};
//=======================================================================================================
bool between(long min, long max, long num)
{
 return (num < min && num > max);
};
//=======================================================================================================
long map(long num, long in_min, long in_max, long out_min, long out_max)
{
  return (num - in_min) * (out_max - out_min + 1) / (in_max - in_min + 1) + out_min;
};
//=======================================================================================================
long limit(long min, long max, long num)
{
 if(num < min) { return min; };
 if(num > max) { return max; };
 return num;
};
//=======================================================================================================
long min(long a, long b)
{
 return a < b ? a : b;
};
//=======================================================================================================
long max(long a, long b)
{
 return a > b ? a : b;
};
//=======================================================================================================
bool getBTN_EXIT_FLAG() { return AbortFlag(); };
void BTN_EXIT_FLAG(bool wait_before_exit) //If true, it waits 2 Seconds before exiting
{
 SetLongAbort(wait_before_exit);
};
//=======================================================================================================
bool BTNPRESSED(unsigned int btn, bool reset = false)
{
 switch (btn) {
  case BTNEXIT:
   if(getBTN_EXIT_FLAG()) {
    return ButtonPressed(BTNEXIT, reset);
   } else {
    return false; //False, because if Long-Press is disabled, it cannot be pressed
   };
   break;
  case BTNRIGHT:
  case BTNLEFT:
  case BTNCENTER:
   return ButtonPressed(btn, reset);
   break;
 }
};
//=======================================================================================================
void pause(int btn = BTNCENTER, int check_delay = 10, bool Wait_Until_Stop = true)
{
 while(!BTNPRESSED(btn)) { Wait(check_delay); };
 while(BTNPRESSED(btn) && Wait_Until_Stop) {};
}
//=======================================================================================================
bool str_isEmpty(string str)
{
 return StrLen(str) == 0;
};
//=======================================================================================================
int str_find_first(string ToSearch, string str)
{
 return Pos(ToSearch, str);
};
//=======================================================================================================
int str_find_first_not(string str, char sym)
{
 if(str_isEmpty(str)) { return 0; };
 int pos = 0;
 char s_sym[];
 s_sym[0] = sym;
 
 for(int i = 0; i < StrLen(str); i++) {
  if(SubStr(str, i, 1) == s_sym) { pos = i; } else { break; };
 }
 
 return pos;
};
//=======================================================================================================
int str_find_last_not(string str, char sym)
{
 if(str_isEmpty(str)) { return 0; };
 int pos = 0;
 char s_sym[];
 s_sym[0] = sym;
 
 for(int i = StrLen(str); i >= 0; i--) {
  if(SubStr(str, i, 1) == s_sym) { pos = i; } else { break; };
 }
 
 return pos;
};
//=======================================================================================================
string str_trim(string str)
{
 if(str_isEmpty(str)) { return ""; };
 string new = "";
 
 int startpos = str_find_first_not(str, " ");
 int endpos = str_find_last_not(str, " ");
 new = SubStr(str, startpos, endpos-startpos+1 );

 return new;
};
//=======================================================================================================
bool CenterTextOut(int y, string txt) {
 if(StrLen(txt) > CHARS_PER_ROW || StrLen(txt) == 0) { ERR = 1; return false; };
 TextOut((LCD_WIDTH-StrLen(txt)*CHAR_WIDTH)/2-5, y, txt);
 return true;
};
//=======================================================================================================
string CenterText(string txt) {
 if(StrLen(txt) > CHARS_PER_ROW || StrLen(txt) == 0) { ERR = 1; return ""; };
 string str = "";
 
 for(int i = 0; i <= (LCD_WIDTH-StrLen(txt)*CHAR_WIDTH)/2-5/CHAR_WIDTH; i++) {
	 str = str + " ";
 };
 
 return str + txt;
};
//=======================================================================================================
bool RightTextOut(int y, string txt) {
 if(StrLen(txt) > CHARS_PER_ROW || StrLen(txt) == 0) { ERR = 1; return false; };
 TextOut(LCD_WIDTH-(StrLen(txt)*CHAR_WIDTH+5), y, txt);
 return true;
};
//=======================================================================================================
string RightText(string txt) {
 if(StrLen(txt) > CHARS_PER_ROW || StrLen(txt) == 0) { ERR = 1; return ""; };
 string str = "";
 
 for(int i = 0; i <= (LCD_WIDTH-(StrLen(txt)*5+5/CHAR_WIDTH)); i++) {
	 str = str + " ";
 };
 
 return str + txt;
};
//=======================================================================================================
void InvertLine(int y)
{
 RectOut(0, y, 100, 8, |DRAW_OPT_INVERT);
};
//=======================================================================================================
long GetNumber(string msg, long min, long max, int switching_time = 100) {//Inclusive
 int value = (max+min)/2; //Average them at the start

 while(!BTNPRESSED(BTNCENTER)) {
  CenterTextOut(LCD_LINE4, msg);
  CenterTextOut(LCD_LINE5, NumToStr(value));
  
  while(BTNPRESSED(BTNRIGHT)) {
   value++;
   Wait(switching_time);
  };
  
  while(BTNPRESSED(BTNLEFT)) {
   value--;
   Wait(switching_time);
  };
  
  //Endless loop
  if (min > value) { value = max; };
  if (value > max) { value = min; };
 };
  
 while(BTNPRESSED(BTNCENTER)) { Wait(10); }; //No accidental press after function
 return value;
};
//=======================================================================================================
unsigned long getProgramRuntime() {
 return CurrentTick() - FirstTick();
};
//=======================================================================================================
bool Bit_Read(unsigned long number, byte idx) {
 if(idx > 32) { return number; };
 return (number >> idx) & 1;
};
unsigned long Bit_Write(unsigned long number, byte idx, bool state) {
 if(idx > 32) { return number; };
 return (number & ~(1 << idx)) | (state << idx);
};
unsigned long Bit_Toggle(unsigned long number, byte idx) {
 if(idx > 32) { return number; };
 return number ^ (1 << idx);
};
